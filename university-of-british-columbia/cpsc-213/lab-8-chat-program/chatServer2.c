// chatServer.c// the main function of your chatServer#include <stdio.h>#include <signal.h>#include <errno.h>#include <stdlib.h>#include <unistd.h>#include <string.h>#include <ctype.h>#include "Socket.h"#include "Thread.h"#include "Packet.h"#include "Semaphore.h"#include "socketStruct.h"struct clientSession{  void *socket;			// The file descriptor to the client  // You may add additional fields to this   // structure if needed    struct Socket *client;  void *session;  unsigned char name[MAX_BYTES];};#define MAX_SESSIONS 3// An array of all the currently active sessions. If a // slot in the array does not corespond to a currently active// session then the socket field will be set to NULL.struct clientSession sessions[MAX_SESSIONS];// A counting semaphore. This is not used until part 4 of the assignment.sem_t *countingSem = NULL;sem_t *lock = NULL;// A chat session is the management thread entity created to manage/monitor// a client connection. It is this functions responsibility to receive data// from the client and then distribute it to the other clients if appropriate. // This routine takes a single argument, a pointer to a struct clientSession. // However, to be type compatible with the function address required by createThread// the paramaterm must be of type void*void *chatSession (void *parm){  // Add any local variable declarations here.  // When the code in here starts executing you know that a connection was   // accepted from a client and that the passed in value is really a   // pointer to a struct clientSession.   struct clientSession *connection = (struct clientSession *) parm;  // Roughly chatSession loops   //                reading data from the client  //                writes the exact received data to other clients,  //                     make sure not to send the data  //                    back to the orginator.  //                only send data to connected clients  //                stop looping when EOF received  // Make sure to close the socket, and free any allocated resources   // Note that the global array sessions contains all the file descriptors of  // the open connections to clients.  // A thread will terminate when execution runs off the end of the code    int check;  int i;  PACKET *packet = calloc (0, sizeof (PACKET));  check = socketRecv (connection->client, packet, sizeof (PACKET));  packet->data[packet->data_len] = '\0';  if (packet->ptype == HELLO)  {    for (i = 0; i < packet->data_len; i++)      connection->name[i] = packet->data[i];        printf ("*%s has entered the conversation.\n", packet->data);  }  // if statement    if (packet->ptype != HELLO)    printf ("Server: Received: ^%s^\n", packet->data);  if (strcmp (&packet->data, "Quit") == 0)  {    socketClose (connection->client);    free (connection);    connection = NULL;  // may cause problems    return 0;  }  // if statement  packet->ptype = CONTINUE;  packet->data_len = 0;  check = socketSend (connection->client, packet, sizeof (PACKET));  if (check <= 0)  {    printf ("Server: send error.\n");    return (void*) -2;  }  // if statement  for ( ; ; )  {    check = socketRecv (connection->client, packet, sizeof (PACKET));    printf ("Client sent: \"%s\"\n", packet->data);    packet->data_len += strlen (connection->name) + 3;    unsigned char tempData [packet->data_len];    sprintf (tempData, "%s: %s", connection->name, packet->data);        int i;    for (i = 0; i < packet->data_len; i++)      packet->data [i] = tempData[i];    if (packet->ptype == BYE)    {      printf ("Server: Client quit.\n");      socketClose (connection->client);           free (connection);      connection->socket = NULL;      connection = NULL;      return (0);    }  // if statement    if (check <= 0)    {      socketClose (connection->client);      return (0);    }  // if statement    packet->data[packet->data_len] = '\0';    if (strcmp (&packet->data, "Quit") == 0)    {      socketClose (connection->client);      free (connection);      connection = NULL;      return 0;    }  // if statement    packet->ptype = DISPLAY;    //int i;    for (i = 0; i < MAX_SESSIONS; i++)    {      if(sessions[i].session != connection->session)      {        if (sessions[i].session != NULL)        {          check = socketSend (sessions[i].client, packet, sizeof(PACKET));          if (check <= 0)          {            //perror ("Server: send error.\n");            return (void*) -2;          }  // if statement        }  // if statement      }  // if statement    }  // for loop  }  // outter for loop    check = socketClose (connection->client);	/* close socket, terminate connection. */  if (check < 0)  {    printf ("Server: close error.\n");    return (void*) -3;  }  // if statement  return NULL;}  // chatSession// Main takes a single argument, the port number to listen on.int main (int argc, char *argv[]){  // Do not remove the following if/then/else  // statement. This setup is needed to deal   // with the situation when a write is made to a   // socket and the other side has already closed down   if (signal (SIGPIPE, SIG_IGN) == SIG_ERR)  {    perror ("sigHandle, SIGPIPE cannot be handled.");    exit (-1);  }  // if statement  printf ("SIGPIPE set to ignore.%d\n", SIGPIPE);  // Add your code and variable declarations starting here.  // Additional comments indicate some of the *important*   // steps the code requires. (i.e Additional actions will be  // required for a proper implementation.) The comments should   // be taken as suggestions only and you may choose to implement things   // differently.  int i;  if (argc != 2)  {    printf ("Usage chatServer [port]\n");    exit (-2);  }  // if statement  // create the server socket to listen on  struct Socket *server = createServerSocket (atoi (argv[1]));  if (server == NULL)		// error check  {    printf ("Server: Could not open port\n");    return (-2);  }  // Loop accepting new connections and for each connection create and start  // a thread to manage the connection. The thread uses the chatSession   // function. Don't forget to put in the connection information in the sessions array  // Also, detatch the thread so that thread resources get collected.  int sessionAvailable = 0;  for ( ; ; )  {    sessionAvailable = 0;    struct Socket *client = malloc (sizeof (struct Socket));          for (i = 0; i < MAX_SESSIONS; i++)    {      if (sessions[i].socket == NULL)        sessionAvailable = 1;    }  // for loop          client = socketAccept (server);	// accept an incomming connection          if (!sessionAvailable)     {      socketClose(client);      continue;    }  // if statement    struct clientSession *inConnection = malloc (sizeof (struct clientSession));    // fill in struct clientSession details    inConnection->socket = (void *) client->sockFD;    inConnection->client = client;    void *thread;    thread = createThread (chatSession, inConnection);    inConnection->session = thread;	// fill in struct clientSession details    // insert incomming connection in to first available sessions[] index    for (i = 0; i < MAX_SESSIONS; i++)    {      if (sessions[i].socket == NULL)      {        sessions[i] = *inConnection;        break;      }  // if statement    }  // for loop          runThread (thread, NULL);	// run thread    detachThread (thread);	// detach thread  }  // outter for loop  for (i = 0; i < MAX_SESSIONS; i++)	// clean up connections  {    if (sessions[i].session != NULL)    {      detachThread (sessions[i].session);      cancelThread (sessions[i].session);      free (sessions[i].session);    }  // if statement  }  // for loop    return 0;}  // main