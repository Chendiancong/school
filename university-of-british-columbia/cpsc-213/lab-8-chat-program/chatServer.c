// chatServer.c// the main function of your chatServer#include <stdio.h>#include <signal.h>#include <errno.h>#include <stdlib.h>#include <unistd.h>#include <string.h>#include <ctype.h>#include "Socket.h"#include "Thread.h"#include "Packet.h"#include "Semaphore.h"#include "socketStruct.h"#define MAX_SESSIONS 3struct clientSession{  void *socket;  // The file descriptor to the client  // You may add additional fields to this   // structure if needed    struct Socket *client;  void *session;};// An array of all the currently active sessions. If a // slot in the array does not corespond to a currently active// session then the socket field will be set to NULL.struct clientSession sessions[MAX_SESSIONS];// A counting semaphore. This is not used until part 4 of the assignment.sem_t *countingSem = NULL;sem_t *lock = NULL;// A chat session is the management thread entity created to manage/monitor// a client connection. It is this functions responsibility to receive data// from the client and then distribute it to the other clients if appropriate. // This routine takes a single argument, a pointer to a struct clientSession. // However, to be type compatible with the function address required by createThread// the paramaterm must be of type void*void *chatSession (void *parm){  // Add any local variable declarations here.  // When the code in here starts executing you know that a connection was   // accepted from a client and that the passed in value is really a   // pointer to a struct clientSession.   struct clientSession *chat_session = (struct clientSession *) parm;  // Roughly chatSession loops   //                reading data from the client  //                writes the exact received data to other clients,  //                     make sure not to send the data  //                    back to the orginator.  //                only send data to connected clients  //                stop looping when EOF received  // Make sure to close the socket, and free any allocated resources   // Note that the global array sessions contains all the file descriptors of  // the open connections to clients.  // A thread will terminate when execution runs off the end of the code    int bytes_read;  int i;  char *message = calloc (0, MAX_BYTES);  for ( ; ; )  {    bytes_read = socketRecv (chat_session->client, message, MAX_BYTES);    if (bytes_read <= 0)    {      printf ("Server: receive error.\n");      socketClose (chat_session->client);      return 0;    }  // if statement    message[bytes_read] = '\0';    printf ("Client sent: \"%s\"\n", message);    if (strcmp (message, "Quit") == 0)    {      socketClose (chat_session->client);      free (chat_session);      chat_session = NULL;      return 0;    }  // if statement    for (i = 0; i < MAX_SESSIONS; i++)    {      if(sessions[i].session != chat_session->session)      {        if (sessions[i].session != NULL)        {          bytes_read = socketSend (sessions[i].client, message, strlen (message));          if (bytes_read <= 0)          {            printf ("Server: connection closed.\n");  // connection closed due to send error            exit (-1);          }  // inner if statement        }  // inner if statement      }  // outter if statement    }  // inner for loop  }  // outter for loop    bytes_read = socketClose (chat_session->client);    if (bytes_read < 0)  {    perror ("Server: close error.\n");    return 0;  }  // if statement  return NULL;}  // chatSession// Main takes a single argument, the port number to listen on.int main (int argc, char *argv[]){  // Do not remove the following if/then/else  // statement. This setup is needed to deal   // with the situation when a write is made to a   // socket and the other side has already closed down   if (signal (SIGPIPE, SIG_IGN) == SIG_ERR)  {    printf ("sigHandle, SIGPIPE cannot be handled.");    return (-1);  }  // if statement  printf ("SIGPIPE set to ignore.%d\n", SIGPIPE);  // Add your code and variable declarations starting here.  // Additional comments indicate some of the *important*   // steps the code requires. (i.e Additional actions will be  // required for a proper implementation.) The comments should   // be taken as suggestions only and you may choose to implement things   // differently.  int i;  if (argc != 2)  {    printf ("Usage: chatServer <port>\n");    return (-2);  }  // if statement  // create the server socket to listen on  struct Socket *server = createServerSocket (atoi (argv[1]));  if (server == NULL)  {    printf ("Server: Could not open port\n");    return (-2);  }  // if statement  // Loop accepting new connections and for each connection create and start  // a thread to manage the connection. The thread uses the chatSession   // function. Don't forget to put in the connection information in the sessions array  // Also, detatch the thread so that thread resources get collected.  for ( ; ; )  {    struct Socket *client = malloc (sizeof (struct Socket));    client = socketAccept (server);        struct clientSession *client_session = malloc (sizeof (struct clientSession));    client_session->socket = (void *) client->sockFD;    client_session->client = client;    void *thread = createThread (chatSession, client_session);    client_session->session = thread;    for (i = 0; i < MAX_SESSIONS; i++)    {      if (sessions[i].socket == NULL)      {        sessions[i] = *client_session;        break;      }  // if statement    }  // for loop    runThread (thread, NULL);    detachThread (thread);  }  // for loop  for (i = 0; i < MAX_SESSIONS; i++)  {    if (sessions[i].session != NULL)    {      detachThread (sessions[i].session);      cancelThread (sessions[i].session);      free (sessions[i].session);    }  // if statement  }  // for loop}  // main